* Notes
** Installing Tk
cpan Tk
** Special purpose registers
Should they be directly addressable?
Does the VM really need separate methods for them?
* To Do
** DONE Assembler should output actual binary
** DONE Create a disassembler
** DONE emulator needs to be able read binary output from assembler
** DONE refactor disassembler and emulator to share disassembly code
** DONE assembler and disassembler needs to support multi-word instructions
First word always has the op code and two operands, but either of those operand might reference the "next word".
For each reference to "next word", an additional word is appended to the instruction. Since there are two operands, each of which may reference "next word" once, this means that the maximum length of an instruction is three words.

When assembling an instruction, the current idea is to replace literals (which may themselves be up to a full word) with "next word" regardless. A future optimization would be to "inline" them if they are less than six bits, the size of an operand (this would be known as a "short form" value).

The correct way to implement this in the assembler seems to be to check if an operand is a value, in which case just encode the value, or if it is a literal, in which case encode "next word" and append the literal as an additional word.

For the disassembler, it seems that every time "next word" is encountered, read the next word and use it in place of "next word".
** DONE emulator needs to support memory
do most chips have dedicated storage for the stack? or is it usually just in RAM?

am I jumping up too high a level here? resolve-operand is basically disassembling values, which get pass to read_value...seems like read_value should be able to act on the values directly?

although resolve_operand does play the important part of inlining "next word"

need read_value and write value, which accept resolved operands

basically what is happening here is that I am disassembling the object code and then writing an interpreter for assembly language

I feel like this is not what I'm supposed to be doing...but I also feel like this will work
** DONE create VM.pm
need strong abstraction around the machine? A VM module that exposes these methods:
read_register
write_register
read_memory
write_memory
** DONE need write_value
** DONE Add support to the emulator for operations besides SET
** DONE implement stack
** DONE need to actually load program into memory (VM::load_program ?)
** DONE implement program counter
** DONE implement flow control instructions (IFE, IFN, IFG, IFB)
need to skip next instruction, not just next word
** DONE assembler needs to support labels
should replace the label with the memory address of the target
** DONE implement JSR instruction
** DONE implement short-form literals
** DONE add support decimal and short form hex literals to assembler
** DONE pad monitor
** DONE place buttons
** DONE layout and bind registers
** DONE disassembler should pretty-print expressions
** TODO test overflow behavior for operators that set overflow
** TODO test that overflow register can be read by instructions
** TODO assembler should accept -v flag
** TODO emulator needs to validate that the input is an object code file
** TODO common namespace for modules
** TODO rename DCPU module to Util
** TODO make sure that I'm compliant w/ the spec on operand evaluation order
* Scratch
Goals: 
- keyboard
- clock / interupts
- Find and run some programs from the internet
- Compare code w/ other assemblers/emulators
- test assembler/emulator interop with other distributions

TODO:
- what about a way to dynamically assemble & load new instructions? A REPL for DCPU-16
- some kind of edge effect with canvas
- play/stop/reset
- clean up fit/finish
- highlight PC and SP
- config file to define attached hardware?

Next:
- new spec
- implement monitor w/ interupts

- encoding of short-form literals is off by one (allow short-form encoding of -1)
- start implementing new opcodes
  - signed math
  - signed bitshift
  - signed conditionals
  - STI/STD
- look at clock / cycle counting

- need to implement "remainder" function for MOD/MDI
