* Notes
** Installing Tk
cpan Tk
* To Do
** DONE Assembler should output actual binary
** DONE Create a disassembler
** DONE emulator needs to be able read binary output from assembler
** DONE refactor disassembler and emulator to share disassembly code
** DONE assembler and disassembler needs to support multi-word instructions
First word always has the op code and two operands, but either of those operand might reference the "next word".
For each reference to "next word", an additional word is appended to the instruction. Since there are two operands, each of which may reference "next word" once, this means that the maximum length of an instruction is three words.

When assembling an instruction, the current idea is to replace literals (which may themselves be up to a full word) with "next word" regardless. A future optimization would be to "inline" them if they are less than six bits, the size of an operand (this would be known as a "short form" value).

The correct way to implement this in the assembler seems to be to check if an operand is a value, in which case just encode the value, or if it is a literal, in which case encode "next word" and append the literal as an additional word.

For the disassembler, it seems that every time "next word" is encountered, read the next word and use it in place of "next word".
** DONE emulator needs to support memory
do most chips have dedicated storage for the stack? or is it usually just in RAM?

am I jumping up too high a level here? resolve-operand is basically disassembling values, which get pass to read_value...seems like read_value should be able to act on the values directly?

although resolve_operand does play the important part of inlining "next word"

need read_value and write value, which accept resolved operands

basically what is happening here is that I am disassembling the object code and then writing an interpreter for assembly language

I feel like this is not what I'm supposed to be doing...but I also feel like this will work
** DONE create VM.pm
need strong abstraction around the machine? A VM module that exposes these methods:
read_register
write_register
read_memory
write_memory
** DONE need write_value
** DONE Add support to the emulator for operations besides SET
** DONE implement stack
** DONE need to actually load program into memory (VM::load_program ?)
** DONE implement program counter
** DONE implement flow control instructions (IFE, IFN, IFG, IFB)
need to skip next instruction, not just next word
** DONE assembler needs to support labels
should replace the label with the memory address of the target
** DONE implement JSR instruction
** DONE implement short-form literals
** DONE add support decimal and short form hex literals to assembler
** TODO pad monitor
** TODO place buttons
** TODO layout and bind registers

** TODO test overflow behavior for operators that set overflow
** TODO test that overflow register can read by instructions
** TODO disassembler should pretty-print expressions
** TODO assembler should accept -v flag
** TODO emulator needs to validate that the input is an object code file
* Scratch
Goals: 
- Find and run some programs from the internet
- Compare code w/ other assemblers/emulators
- test assembler/emulator interop with other distributions
** Graphics

- graphics
- keyboard
- new spec
- clock / interupts


- what about a way to dynamically assemble & load new instructions? A REPL for DCPU-16

need to lay out the GUI.
bind ESC to quit
some kind of edge effect with canvas

- play/stop/reset
- clean up fit/finish
- title
- scrat image?
